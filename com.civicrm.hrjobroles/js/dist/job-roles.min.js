/*!
angular-xeditable - 0.1.8
Edit-in-place for angular.js
Build date: 2014-01-10 
*/
angular.module("xeditable",[]).value("editableOptions",{theme:"default",buttons:"right",blurElem:"cancel",blurForm:"ignore",activate:"focus"}),angular.module("xeditable").directive("editableBsdate",["editableDirectiveFactory",function(a){return a({directiveName:"editableBsdate",inputTpl:'<input type="text">'})}]),angular.module("xeditable").directive("editableBstime",["editableDirectiveFactory",function(a){return a({directiveName:"editableBstime",inputTpl:"<timepicker></timepicker>",render:function(){this.parent.render.call(this);var a=angular.element('<div class="well well-small" style="display:inline-block;"></div>');a.attr("ng-model",this.inputEl.attr("ng-model")),this.inputEl.removeAttr("ng-model"),this.attrs.eNgChange&&(a.attr("ng-change",this.inputEl.attr("ng-change")),this.inputEl.removeAttr("ng-change")),this.inputEl.wrap(a)}})}]),angular.module("xeditable").directive("editableCheckbox",["editableDirectiveFactory",function(a){return a({directiveName:"editableCheckbox",inputTpl:'<input type="checkbox">',render:function(){this.parent.render.call(this),this.attrs.eTitle&&(this.inputEl.wrap("<label></label>"),this.inputEl.after(angular.element("<span></span>").text(this.attrs.eTitle)))},autosubmit:function(){var a=this;a.inputEl.bind("change",function(){setTimeout(function(){a.scope.$apply(function(){a.scope.$form.$submit()})},500)})}})}]),angular.module("xeditable").directive("editableChecklist",["editableDirectiveFactory","editableNgOptionsParser",function(a,b){return a({directiveName:"editableChecklist",inputTpl:"<span></span>",useCopy:!0,render:function(){this.parent.render.call(this);var a=b(this.attrs.eNgOptions),c='<label ng-repeat="'+a.ngRepeat+'">'+'<input type="checkbox" checklist-model="$parent.$data" checklist-value="'+a.locals.valueFn+'">'+'<span ng-bind="'+a.locals.displayFn+'"></span></label>';this.inputEl.removeAttr("ng-model"),this.inputEl.removeAttr("ng-options"),this.inputEl.html(c)}})}]),function(){var a="text|email|tel|number|url|search|color|date|datetime|time|month|week".split("|");angular.forEach(a,function(a){var b="editable"+a.charAt(0).toUpperCase()+a.slice(1);angular.module("xeditable").directive(b,["editableDirectiveFactory",function(c){return c({directiveName:b,inputTpl:'<input type="'+a+'">'})}])}),angular.module("xeditable").directive("editableRange",["editableDirectiveFactory",function(a){return a({directiveName:"editableRange",inputTpl:'<input type="range" id="range" name="range">',render:function(){this.parent.render.call(this),this.inputEl.after("<output>{{$data}}</output>")}})}])}(),angular.module("xeditable").directive("editableRadiolist",["editableDirectiveFactory","editableNgOptionsParser",function(a,b){return a({directiveName:"editableRadiolist",inputTpl:"<span></span>",render:function(){this.parent.render.call(this);var a=b(this.attrs.eNgOptions),c='<label ng-repeat="'+a.ngRepeat+'">'+'<input type="radio" ng-model="$parent.$data" value="{{'+a.locals.valueFn+'}}">'+'<span ng-bind="'+a.locals.displayFn+'"></span></label>';this.inputEl.removeAttr("ng-model"),this.inputEl.removeAttr("ng-options"),this.inputEl.html(c)},autosubmit:function(){var a=this;a.inputEl.bind("change",function(){setTimeout(function(){a.scope.$apply(function(){a.scope.$form.$submit()})},500)})}})}]),angular.module("xeditable").directive("editableSelect",["editableDirectiveFactory",function(a){return a({directiveName:"editableSelect",inputTpl:"<select></select>",autosubmit:function(){var a=this;a.inputEl.bind("change",function(){a.scope.$apply(function(){a.scope.$form.$submit()})})}})}]),angular.module("xeditable").directive("editableTextarea",["editableDirectiveFactory",function(a){return a({directiveName:"editableTextarea",inputTpl:"<textarea></textarea>",addListeners:function(){var a=this;a.parent.addListeners.call(a),a.single&&"no"!==a.buttons&&a.autosubmit()},autosubmit:function(){var a=this;a.inputEl.bind("keydown",function(b){(b.ctrlKey||b.metaKey)&&13===b.keyCode&&a.scope.$apply(function(){a.scope.$form.$submit()})})}})}]),angular.module("xeditable").factory("editableController",["$q","editableUtils",function(a,b){function c(a,c,d,e,f,g,h,i,j){var k,l,m=this;m.scope=a,m.elem=d,m.attrs=c,m.inputEl=null,m.editorEl=null,m.single=!0,m.error="",m.theme=f[g.theme]||f["default"],m.parent={},m.inputTpl="",m.directiveName="",m.useCopy=!1,m.single=null,m.buttons="right",m.init=function(b){if(m.single=b,m.name=c.eName||c[m.directiveName],!c[m.directiveName])throw"You should provide value for `"+m.directiveName+"` in editable element!";k=e(c[m.directiveName]),m.buttons=m.single?m.attrs.buttons||g.buttons:"no",c.eName&&m.scope.$watch("$data",function(a){m.scope.$form.$data[c.eName]=a}),c.onshow&&(m.onshow=function(){return m.catchError(e(c.onshow)(a))}),c.onhide&&(m.onhide=function(){return e(c.onhide)(a)}),c.oncancel&&(m.oncancel=function(){return e(c.oncancel)(a)}),c.onbeforesave&&(m.onbeforesave=function(){return m.catchError(e(c.onbeforesave)(a))}),c.onaftersave&&(m.onaftersave=function(){return m.catchError(e(c.onaftersave)(a))}),a.$parent.$watch(c[m.directiveName],function(){m.handleEmpty()})},m.render=function(){var a=m.theme;m.inputEl=angular.element(m.inputTpl),m.controlsEl=angular.element(a.controlsTpl),m.controlsEl.append(m.inputEl),"no"!==m.buttons&&(m.buttonsEl=angular.element(a.buttonsTpl),m.submitEl=angular.element(a.submitTpl),m.cancelEl=angular.element(a.cancelTpl),m.buttonsEl.append(m.submitEl).append(m.cancelEl),m.controlsEl.append(m.buttonsEl),m.inputEl.addClass("editable-has-buttons")),m.errorEl=angular.element(a.errorTpl),m.controlsEl.append(m.errorEl),m.editorEl=angular.element(m.single?a.formTpl:a.noformTpl),m.editorEl.append(m.controlsEl);for(var d in c.$attr)if(!(d.length<=1)){var e=!1,f=d.substring(1,2);if("e"===d.substring(0,1)&&f===f.toUpperCase()&&(e=d.substring(1),"Form"!==e&&"NgSubmit"!==e)){e=e.substring(0,1).toLowerCase()+b.camelToDash(e.substring(1));var h=""===c[d]?e:c[d];m.inputEl.attr(e,h)}}m.inputEl.addClass("editable-input"),m.inputEl.attr("ng-model","$data"),m.editorEl.addClass(b.camelToDash(m.directiveName)),m.single&&(m.editorEl.attr("editable-form","$form"),m.editorEl.attr("blur",m.attrs.blur||("no"===m.buttons?"cancel":g.blurElem))),angular.isFunction(a.postrender)&&a.postrender.call(m)},m.setLocalValue=function(){m.scope.$data=m.useCopy?angular.copy(k(a.$parent)):k(a.$parent)},m.show=function(){return m.setLocalValue(),m.render(),d.after(m.editorEl),i(m.editorEl)(a),m.addListeners(),d.addClass("editable-hide"),m.onshow()},m.hide=function(){return m.editorEl.remove(),d.removeClass("editable-hide"),m.onhide()},m.cancel=function(){m.oncancel()},m.addListeners=function(){m.inputEl.bind("keyup",function(a){if(m.single)switch(a.keyCode){case 27:m.scope.$apply(function(){m.scope.$form.$cancel()})}}),m.single&&"no"===m.buttons&&m.autosubmit(),m.editorEl.bind("click",function(a){1===a.which&&m.scope.$form.$visible&&(m.scope.$form._clicked=!0)})},m.setWaiting=function(a){a?(l=!m.inputEl.attr("disabled")&&!m.inputEl.attr("ng-disabled")&&!m.inputEl.attr("ng-enabled"),l&&(m.inputEl.attr("disabled","disabled"),m.buttonsEl&&m.buttonsEl.find("button").attr("disabled","disabled"))):l&&(m.inputEl.removeAttr("disabled"),m.buttonsEl&&m.buttonsEl.find("button").removeAttr("disabled"))},m.activate=function(){setTimeout(function(){var a=m.inputEl[0];"focus"===g.activate&&a.focus&&a.focus(),"select"===g.activate&&a.select&&a.select()},0)},m.setError=function(b){angular.isObject(b)||(a.$error=b,m.error=b)},m.catchError=function(a,b){return angular.isObject(a)&&b!==!0?j.when(a).then(angular.bind(this,function(a){this.catchError(a,!0)}),angular.bind(this,function(a){this.catchError(a,!0)})):b&&angular.isObject(a)&&a.status&&200!==a.status&&a.data&&angular.isString(a.data)?(this.setError(a.data),a=a.data):angular.isString(a)&&this.setError(a),a},m.save=function(){k.assign(a.$parent,angular.copy(m.scope.$data))},m.handleEmpty=function(){var b=k(a.$parent),c=null===b||void 0===b||""===b||angular.isArray(b)&&0===b.length;d.toggleClass("editable-empty",c)},m.autosubmit=angular.noop,m.onshow=angular.noop,m.onhide=angular.noop,m.oncancel=angular.noop,m.onbeforesave=angular.noop,m.onaftersave=angular.noop}return c.$inject=["$scope","$attrs","$element","$parse","editableThemes","editableOptions","$rootScope","$compile","$q"],c}]),angular.module("xeditable").factory("editableDirectiveFactory",["$parse","$compile","editableThemes","$rootScope","$document","editableController","editableFormController",function(a,b,c,d,e,f,g){return function(b){return{restrict:"A",scope:!0,require:[b.directiveName,"?^form"],controller:f,link:function(c,f,h,i){var j,k=i[0],l=!1;if(i[1])j=i[1],l=!0;else if(h.eForm){var m=a(h.eForm)(c);if(m)j=m,l=!0;else for(var n=0;n<e[0].forms.length;n++)if(e[0].forms[n].name===h.eForm){j=null,l=!0;break}}if(angular.forEach(b,function(a,b){void 0!==k[b]&&(k.parent[b]=k[b])}),angular.extend(k,b),k.init(!l),c.$editable=k,f.addClass("editable"),l)if(j){if(c.$form=j,!c.$form.$addEditable)throw"Form with editable elements should have `editable-form` attribute.";c.$form.$addEditable(k)}else d.$$editableBuffer=d.$$editableBuffer||{},d.$$editableBuffer[h.eForm]=d.$$editableBuffer[h.eForm]||[],d.$$editableBuffer[h.eForm].push(k),c.$form=null;else c.$form=g(),c.$form.$addEditable(k),h.eForm&&(c.$parent[h.eForm]=c.$form),h.eForm||(f.addClass("editable-click"),f.bind("click",function(a){a.preventDefault(),a.editable=k,c.$apply(function(){c.$form.$show()})}))}}}}]),angular.module("xeditable").factory("editableFormController",["$parse","$document","$rootScope","editablePromiseCollection","editableUtils",function(a,b,c,d,e){var f=[];b.bind("click",function(a){if(1===a.which){for(var b=[],d=[],e=0;e<f.length;e++)f[e]._clicked?f[e]._clicked=!1:f[e].$waiting||("cancel"===f[e]._blur&&b.push(f[e]),"submit"===f[e]._blur&&d.push(f[e]));(b.length||d.length)&&c.$apply(function(){angular.forEach(b,function(a){a.$cancel()}),angular.forEach(d,function(a){a.$submit()})})}});var g={$addEditable:function(a){this.$editables.push(a),a.elem.bind("$destroy",angular.bind(this,this.$removeEditable,a)),a.scope.$form||(a.scope.$form=this),this.$visible&&a.catchError(a.show())},$removeEditable:function(a){for(var b=0;b<this.$editables.length;b++)if(this.$editables[b]===a)return this.$editables.splice(b,1),void 0},$show:function(){if(!this.$visible){this.$visible=!0;var a=d();a.when(this.$onshow()),this.$setError(null,""),angular.forEach(this.$editables,function(b){a.when(b.show())}),a.then({onWait:angular.bind(this,this.$setWaiting),onTrue:angular.bind(this,this.$activate),onFalse:angular.bind(this,this.$activate),onString:angular.bind(this,this.$activate)}),setTimeout(angular.bind(this,function(){this._clicked=!1,-1===e.indexOf(f,this)&&f.push(this)}),0)}},$activate:function(a){var b;if(this.$editables.length){if(angular.isString(a))for(b=0;b<this.$editables.length;b++)if(this.$editables[b].name===a)return this.$editables[b].activate(),void 0;for(b=0;b<this.$editables.length;b++)if(this.$editables[b].error)return this.$editables[b].activate(),void 0;this.$editables[0].activate()}},$hide:function(){this.$visible&&(this.$visible=!1,this.$onhide(),angular.forEach(this.$editables,function(a){a.hide()}),e.arrayRemove(f,this))},$cancel:function(){this.$visible&&(this.$oncancel(),angular.forEach(this.$editables,function(a){a.cancel()}),this.$hide())},$setWaiting:function(a){this.$waiting=!!a,angular.forEach(this.$editables,function(b){b.setWaiting(!!a)})},$setError:function(a,b){angular.forEach(this.$editables,function(c){a&&c.name!==a||c.setError(b)})},$submit:function(){function a(a){var b=d();b.when(this.$onbeforesave()),b.then({onWait:angular.bind(this,this.$setWaiting),onTrue:a?angular.bind(this,this.$save):angular.bind(this,this.$hide),onFalse:angular.bind(this,this.$hide),onString:angular.bind(this,this.$activate)})}if(!this.$waiting){this.$setError(null,"");var b=d();angular.forEach(this.$editables,function(a){b.when(a.onbeforesave())}),b.then({onWait:angular.bind(this,this.$setWaiting),onTrue:angular.bind(this,a,!0),onFalse:angular.bind(this,a,!1),onString:angular.bind(this,this.$activate)})}},$save:function(){angular.forEach(this.$editables,function(a){a.save()});var a=d();a.when(this.$onaftersave()),angular.forEach(this.$editables,function(b){a.when(b.onaftersave())}),a.then({onWait:angular.bind(this,this.$setWaiting),onTrue:angular.bind(this,this.$hide),onFalse:angular.bind(this,this.$hide),onString:angular.bind(this,this.$activate)})},$onshow:angular.noop,$oncancel:angular.noop,$onhide:angular.noop,$onbeforesave:angular.noop,$onaftersave:angular.noop};return function(){return angular.extend({$editables:[],$visible:!1,$waiting:!1,$data:{},_clicked:!1,_blur:null},g)}}]),angular.module("xeditable").directive("editableForm",["$rootScope","$parse","editableFormController","editableOptions",function(a,b,c,d){return{restrict:"A",require:["form"],compile:function(){return{pre:function(b,d,e,f){var g,h=f[0];e.editableForm?b[e.editableForm]&&b[e.editableForm].$show?(g=b[e.editableForm],angular.extend(h,g)):(g=c(),b[e.editableForm]=g,angular.extend(g,h)):(g=c(),angular.extend(h,g));var i=a.$$editableBuffer,j=h.$name;j&&i&&i[j]&&(angular.forEach(i[j],function(a){g.$addEditable(a)}),delete i[j])},post:function(a,c,e,f){var g;g=e.editableForm&&a[e.editableForm]&&a[e.editableForm].$show?a[e.editableForm]:f[0],e.onshow&&(g.$onshow=angular.bind(g,b(e.onshow),a)),e.onhide&&(g.$onhide=angular.bind(g,b(e.onhide),a)),e.oncancel&&(g.$oncancel=angular.bind(g,b(e.oncancel),a)),e.shown&&b(e.shown)(a)&&g.$show(),g._blur=e.blur||d.blurForm,e.ngSubmit||e.submit||(e.onbeforesave&&(g.$onbeforesave=function(){return b(e.onbeforesave)(a,{$data:g.$data})}),e.onaftersave&&(g.$onaftersave=function(){return b(e.onaftersave)(a,{$data:g.$data})}),c.bind("submit",function(b){b.preventDefault(),a.$apply(function(){g.$submit()})})),c.bind("click",function(a){1===a.which&&g.$visible&&(g._clicked=!0)})}}}}}]),angular.module("xeditable").factory("editablePromiseCollection",["$q",function(a){function b(){return{promises:[],hasFalse:!1,hasString:!1,when:function(b,c){if(b===!1)this.hasFalse=!0;else if(!c&&angular.isObject(b))this.promises.push(a.when(b));else{if(!angular.isString(b))return;this.hasString=!0}},then:function(b){function c(){h.hasString||h.hasFalse?!h.hasString&&h.hasFalse?e():f():d()}b=b||{};var d=b.onTrue||angular.noop,e=b.onFalse||angular.noop,f=b.onString||angular.noop,g=b.onWait||angular.noop,h=this;this.promises.length?(g(!0),a.all(this.promises).then(function(a){g(!1),angular.forEach(a,function(a){h.when(a,!0)}),c()},function(){g(!1),f()})):c()}}}return b}]),angular.module("xeditable").factory("editableUtils",[function(){return{indexOf:function(a,b){if(a.indexOf)return a.indexOf(b);for(var c=0;c<a.length;c++)if(b===a[c])return c;return-1},arrayRemove:function(a,b){var c=this.indexOf(a,b);return c>=0&&a.splice(c,1),b},camelToDash:function(a){var b=/[A-Z]/g;return a.replace(b,function(a,b){return(b?"-":"")+a.toLowerCase()})},dashToCamel:function(a){var b=/([\:\-\_]+(.))/g,c=/^moz([A-Z])/;return a.replace(b,function(a,b,c,d){return d?c.toUpperCase():c}).replace(c,"Moz$1")}}}]),angular.module("xeditable").factory("editableNgOptionsParser",[function(){function a(a){var c;if(!(c=a.match(b)))throw"ng-options parse error";var d,e=c[2]||c[1],f=c[4]||c[6],g=c[5],h=(c[3]||"",c[2]?c[1]:f),i=c[7],j=c[8],k=j?c[8]:null;return void 0===g?(d=f+" in "+i,void 0!==j&&(d+=" track by "+k)):d="("+g+", "+f+") in "+i,{ngRepeat:d,locals:{valueName:f,keyName:g,valueFn:h,displayFn:e}}}var b=/^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/;return a}]),angular.module("xeditable").factory("editableThemes",function(){var a={"default":{formTpl:'<form class="editable-wrap"></form>',noformTpl:'<span class="editable-wrap"></span>',controlsTpl:'<span class="editable-controls"></span>',inputTpl:"",errorTpl:'<div class="editable-error" ng-show="$error" ng-bind="$error"></div>',buttonsTpl:'<span class="editable-buttons"></span>',submitTpl:'<button type="submit">save</button>',cancelTpl:'<button type="button" ng-click="$form.$cancel()">cancel</button>'},bs2:{formTpl:'<form class="form-inline editable-wrap" role="form"></form>',noformTpl:'<span class="editable-wrap"></span>',controlsTpl:'<div class="editable-controls controls control-group" ng-class="{\'error\': $error}"></div>',inputTpl:"",errorTpl:'<div class="editable-error help-block" ng-show="$error" ng-bind="$error"></div>',buttonsTpl:'<span class="editable-buttons"></span>',submitTpl:'<button type="submit" class="btn btn-primary"><span class="icon-ok icon-white"></span></button>',cancelTpl:'<button type="button" class="btn" ng-click="$form.$cancel()"><span class="icon-remove"></span></button>'},bs3:{formTpl:'<form class="form-inline editable-wrap" role="form"></form>',noformTpl:'<span class="editable-wrap"></span>',controlsTpl:'<div class="editable-controls form-group" ng-class="{\'has-error\': $error}"></div>',inputTpl:"",errorTpl:'<div class="editable-error help-block" ng-show="$error" ng-bind="$error"></div>',buttonsTpl:'<span class="editable-buttons"></span>',submitTpl:'<button type="submit" class="btn btn-primary"><span class="glyphicon glyphicon-ok"></span></button>',cancelTpl:'<button type="button" class="btn btn-default" ng-click="$form.$cancel()"><span class="glyphicon glyphicon-remove"></span></button>',buttonsClass:"",inputClass:"",postrender:function(){switch(this.directiveName){case"editableText":case"editableSelect":case"editableTextarea":case"editableEmail":case"editableTel":case"editableNumber":case"editableUrl":case"editableSearch":case"editableDate":case"editableDatetime":case"editableTime":case"editableMonth":case"editableWeek":if(this.inputEl.addClass("form-control"),this.theme.inputClass){if(this.inputEl.attr("multiple")&&("input-sm"===this.theme.inputClass||"input-lg"===this.theme.inputClass))break;this.inputEl.addClass(this.theme.inputClass)}}this.buttonsEl&&this.theme.buttonsClass&&this.buttonsEl.find("button").addClass(this.theme.buttonsClass)}}};return a});
/**
 * Bunch of useful filters for angularJS(with no external dependencies!)
 * @version v0.5.4 - 2015-02-20 * @link https://github.com/a8m/angular-filter
 * @author Ariel Mashraki <ariel@mashraki.co.il>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */!function(a,b,c){"use strict";function d(a){return D(a)?a:Object.keys(a).map(function(b){return a[b]})}function e(a){return null===a}function f(a,b){var d=Object.keys(a);return-1==d.map(function(d){return b[d]!==c&&b[d]==a[d]}).indexOf(!1)}function g(a,b){if(""===b)return a;var c=a.indexOf(b.charAt(0));return-1===c?!1:g(a.substr(c+1),b.substr(1))}function h(a,b,c){var d=0;return a.filter(function(a){var e=x(c)?b>d&&c(a):b>d;return d=e?d+1:d,e})}function i(a,b,c){return c.round(a*c.pow(10,b))/c.pow(10,b)}function j(a,b,c){b=b||[];var d=Object.keys(a);return d.forEach(function(d){if(C(a[d])&&!D(a[d])){var e=c?c+"."+d:c;j(a[d],b,e||d)}else{var f=c?c+"."+d:d;b.push(f)}}),b}function k(a){return a&&a.$evalAsync&&a.$watch}function l(){return function(a,b){return a>b}}function m(){return function(a,b){return a>=b}}function n(){return function(a,b){return b>a}}function o(){return function(a,b){return b>=a}}function p(){return function(a,b){return a==b}}function q(){return function(a,b){return a!=b}}function r(){return function(a,b){return a===b}}function s(){return function(a,b){return a!==b}}function t(a){return function(b,c){return b=C(b)?d(b):b,!D(b)||y(c)?!1:b.some(function(b){return C(b)||z(c)?a(c)(b):b===c})}}function u(a,b){return b=b||0,b>=a.length?a:D(a[b])?u(a.slice(0,b).concat(a[b],a.slice(b+1)),b):u(a,b+1)}function v(a){return function(b,c){function e(a,b){return y(b)?!1:a.some(function(a){return H(a,b)})}if(b=C(b)?d(b):b,!D(b))return b;var f=[],g=a(c);return b.filter(y(c)?function(a,b,c){return c.indexOf(a)===b}:function(a){var b=g(a);return e(f,b)?!1:(f.push(b),!0)})}}function w(a,b,c){return b?a+c+w(a,--b,c):a}var x=b.isDefined,y=b.isUndefined,z=b.isFunction,A=b.isString,B=b.isNumber,C=b.isObject,D=b.isArray,E=b.forEach,F=b.extend,G=b.copy,H=b.equals;String.prototype.contains||(String.prototype.contains=function(){return-1!==String.prototype.indexOf.apply(this,arguments)}),b.module("a8m.angular",[]).filter("isUndefined",function(){return function(a){return b.isUndefined(a)}}).filter("isDefined",function(){return function(a){return b.isDefined(a)}}).filter("isFunction",function(){return function(a){return b.isFunction(a)}}).filter("isString",function(){return function(a){return b.isString(a)}}).filter("isNumber",function(){return function(a){return b.isNumber(a)}}).filter("isArray",function(){return function(a){return b.isArray(a)}}).filter("isObject",function(){return function(a){return b.isObject(a)}}).filter("isEqual",function(){return function(a,c){return b.equals(a,c)}}),b.module("a8m.conditions",[]).filter({isGreaterThan:l,">":l,isGreaterThanOrEqualTo:m,">=":m,isLessThan:n,"<":n,isLessThanOrEqualTo:o,"<=":o,isEqualTo:p,"==":p,isNotEqualTo:q,"!=":q,isIdenticalTo:r,"===":r,isNotIdenticalTo:s,"!==":s}),b.module("a8m.is-null",[]).filter("isNull",function(){return function(a){return e(a)}}),b.module("a8m.after-where",[]).filter("afterWhere",function(){return function(a,b){if(a=C(a)?d(a):a,!D(a)||y(b))return a;var c=a.map(function(a){return f(b,a)}).indexOf(!0);return a.slice(-1===c?0:c)}}),b.module("a8m.after",[]).filter("after",function(){return function(a,b){return a=C(a)?d(a):a,D(a)?a.slice(b):a}}),b.module("a8m.before-where",[]).filter("beforeWhere",function(){return function(a,b){if(a=C(a)?d(a):a,!D(a)||y(b))return a;var c=a.map(function(a){return f(b,a)}).indexOf(!0);return a.slice(0,-1===c?a.length:++c)}}),b.module("a8m.before",[]).filter("before",function(){return function(a,b){return a=C(a)?d(a):a,D(a)?a.slice(0,b?--b:b):a}}),b.module("a8m.concat",[]).filter("concat",[function(){return function(a,b){if(y(b))return a;if(D(a))return a.concat(C(b)?d(b):b);if(C(a)){var c=d(a);return c.concat(C(b)?d(b):b)}return a}}]),b.module("a8m.contains",[]).filter({contains:["$parse",t],some:["$parse",t]}),b.module("a8m.count-by",[]).filter("countBy",["$parse",function(a){return function(b,c){var e,f={},g=a(c);return b=C(b)?d(b):b,!D(b)||y(c)?b:(b.forEach(function(a){e=g(a),f[e]||(f[e]=0),f[e]++}),f)}}]),b.module("a8m.defaults",[]).filter("defaults",["$parse",function(a){return function(b,c){if(b=C(b)?d(b):b,!D(b)||!C(c))return b;var e=j(c);return b.forEach(function(b){e.forEach(function(d){var e=a(d),f=e.assign;y(e(b))&&f(b,e(c))})}),b}}]),b.module("a8m.every",[]).filter("every",["$parse",function(a){return function(b,c){return b=C(b)?d(b):b,!D(b)||y(c)?!0:b.every(function(b){return C(b)||z(c)?a(c)(b):b===c})}}]),b.module("a8m.filter-by",[]).filter("filterBy",["$parse",function(a){return function(b,e,f){var g;return f=A(f)||B(f)?String(f).toLowerCase():c,b=C(b)?d(b):b,!D(b)||y(f)?b:b.filter(function(b){return e.some(function(c){if(~c.indexOf("+")){var d=c.replace(new RegExp("\\s","g"),"").split("+");g=d.reduce(function(c,d,e){return 1===e?a(c)(b)+" "+a(d)(b):c+" "+a(d)(b)})}else g=a(c)(b);return A(g)||B(g)?String(g).toLowerCase().contains(f):!1})})}}]),b.module("a8m.first",[]).filter("first",["$parse",function(a){return function(b){var e,f,g;return b=C(b)?d(b):b,D(b)?(g=Array.prototype.slice.call(arguments,1),e=B(g[0])?g[0]:1,f=B(g[0])?B(g[1])?c:g[1]:g[0],g.length?h(b,e,f?a(f):f):b[0]):b}}]),b.module("a8m.flatten",[]).filter("flatten",function(){return function(a,b){return b=b||!1,a=C(a)?d(a):a,D(a)?b?[].concat.apply([],a):u(a,0):a}}),b.module("a8m.fuzzy-by",[]).filter("fuzzyBy",["$parse",function(a){return function(b,c,e,f){var h,i,j=f||!1;return b=C(b)?d(b):b,!D(b)||y(c)||y(e)?b:(i=a(c),b.filter(function(a){return h=i(a),A(h)?(h=j?h:h.toLowerCase(),e=j?e:e.toLowerCase(),g(h,e)!==!1):!1}))}}]),b.module("a8m.fuzzy",[]).filter("fuzzy",function(){return function(a,b,c){function e(a,b){var c,d,e=Object.keys(a);return 0<e.filter(function(e){return c=a[e],d?!0:A(c)?(c=f?c:c.toLowerCase(),d=g(c,b)!==!1):!1}).length}var f=c||!1;return a=C(a)?d(a):a,!D(a)||y(b)?a:(b=f?b:b.toLowerCase(),a.filter(function(a){return A(a)?(a=f?a:a.toLowerCase(),g(a,b)!==!1):C(a)?e(a,b):!1}))}}),b.module("a8m.group-by",["a8m.filter-watcher"]).filter("groupBy",["$parse","filterWatcher",function(a,b){return function(c,d){function e(a,b){var c,d={};return E(a,function(a){c=b(a),d[c]||(d[c]=[]),d[c].push(a)}),d}if(!C(c)||y(d))return c;var f=a(d);return b.isMemoized("groupBy",arguments)||b.memoize("groupBy",arguments,this,e(c,f))}}]),b.module("a8m.is-empty",[]).filter("isEmpty",function(){return function(a){return C(a)?!d(a).length:!a.length}}),b.module("a8m.join",[]).filter("join",function(){return function(a,b){return y(a)||!D(a)?a:(y(b)&&(b=" "),a.join(b))}}),b.module("a8m.last",[]).filter("last",["$parse",function(a){return function(b){var e,f,g,i=G(b);return i=C(i)?d(i):i,D(i)?(g=Array.prototype.slice.call(arguments,1),e=B(g[0])?g[0]:1,f=B(g[0])?B(g[1])?c:g[1]:g[0],g.length?h(i.reverse(),e,f?a(f):f).reverse():i[i.length-1]):i}}]),b.module("a8m.map",[]).filter("map",["$parse",function(a){return function(b,c){return b=C(b)?d(b):b,!D(b)||y(c)?b:b.map(function(b){return a(c)(b)})}}]),b.module("a8m.omit",[]).filter("omit",["$parse",function(a){return function(b,c){return b=C(b)?d(b):b,!D(b)||y(c)?b:b.filter(function(b){return!a(c)(b)})}}]),b.module("a8m.pick",[]).filter("pick",["$parse",function(a){return function(b,c){return b=C(b)?d(b):b,!D(b)||y(c)?b:b.filter(function(b){return a(c)(b)})}}]),b.module("a8m.remove-with",[]).filter("removeWith",function(){return function(a,b){return y(b)?a:(a=C(a)?d(a):a,a.filter(function(a){return!f(b,a)}))}}),b.module("a8m.remove",[]).filter("remove",function(){return function(a){a=C(a)?d(a):a;var b=Array.prototype.slice.call(arguments,1);return D(a)?a.filter(function(a){return!b.some(function(b){return H(b,a)})}):a}}),b.module("a8m.reverse",[]).filter("reverse",[function(){return function(a){return a=C(a)?d(a):a,A(a)?a.split("").reverse().join(""):D(a)?a.slice().reverse():a}}]),b.module("a8m.search-field",[]).filter("searchField",["$parse",function(a){return function(b){var c,e;b=C(b)?d(b):b;var f=Array.prototype.slice.call(arguments,1);return D(b)&&f.length?b.map(function(b){return e=f.map(function(d){return(c=a(d))(b)}).join(" "),F(b,{searchField:e})}):b}}]),b.module("a8m.to-array",[]).filter("toArray",function(){return function(a,b){return C(a)?b?Object.keys(a).map(function(b){return F(a[b],{$key:b})}):d(a):a}}),b.module("a8m.unique",[]).filter({unique:["$parse",v],uniq:["$parse",v]}),b.module("a8m.where",[]).filter("where",function(){return function(a,b){return y(b)?a:(a=C(a)?d(a):a,a.filter(function(a){return f(b,a)}))}}),b.module("a8m.xor",[]).filter("xor",["$parse",function(a){return function(b,c,e){function f(b,c){var d=a(e);return c.some(function(a){return e?H(d(a),d(b)):H(a,b)})}return e=e||!1,b=C(b)?d(b):b,c=C(c)?d(c):c,D(b)&&D(c)?b.concat(c).filter(function(a){return!(f(a,b)&&f(a,c))}):b}}]),b.module("a8m.math.byteFmt",["a8m.math"]).filter("byteFmt",["$math",function(a){return function(b,c){return B(c)&&isFinite(c)&&c%1===0&&c>=0&&B(b)&&isFinite(b)?1024>b?i(b,c,a)+" B":1048576>b?i(b/1024,c,a)+" KB":1073741824>b?i(b/1048576,c,a)+" MB":i(b/1073741824,c,a)+" GB":"NaN"}}]),b.module("a8m.math.degrees",["a8m.math"]).filter("degrees",["$math",function(a){return function(b,c){if(B(c)&&isFinite(c)&&c%1===0&&c>=0&&B(b)&&isFinite(b)){var d=180*b/a.PI;return a.round(d*a.pow(10,c))/a.pow(10,c)}return"NaN"}}]),b.module("a8m.math.kbFmt",["a8m.math"]).filter("kbFmt",["$math",function(a){return function(b,c){return B(c)&&isFinite(c)&&c%1===0&&c>=0&&B(b)&&isFinite(b)?1024>b?i(b,c,a)+" KB":1048576>b?i(b/1024,c,a)+" MB":i(b/1048576,c,a)+" GB":"NaN"}}]),b.module("a8m.math",[]).factory("$math",["$window",function(a){return a.Math}]),b.module("a8m.math.max",["a8m.math"]).filter("max",["$math","$parse",function(a,b){function c(c,d){var e=c.map(function(a){return b(d)(a)});return e.indexOf(a.max.apply(a,e))}return function(b,d){return D(b)?y(d)?a.max.apply(a,b):b[c(b,d)]:b}}]),b.module("a8m.math.min",["a8m.math"]).filter("min",["$math","$parse",function(a,b){function c(c,d){var e=c.map(function(a){return b(d)(a)});return e.indexOf(a.min.apply(a,e))}return function(b,d){return D(b)?y(d)?a.min.apply(a,b):b[c(b,d)]:b}}]),b.module("a8m.math.percent",["a8m.math"]).filter("percent",["$math","$window",function(a,b){return function(c,d,e){var f=A(c)?b.Number(c):c;return d=d||100,e=e||!1,!B(f)||b.isNaN(f)?c:e?a.round(f/d*100):f/d*100}}]),b.module("a8m.math.radians",["a8m.math"]).filter("radians",["$math",function(a){return function(b,c){if(B(c)&&isFinite(c)&&c%1===0&&c>=0&&B(b)&&isFinite(b)){var d=3.14159265359*b/180;return a.round(d*a.pow(10,c))/a.pow(10,c)}return"NaN"}}]),b.module("a8m.math.radix",[]).filter("radix",function(){return function(a,b){var c=/^[2-9]$|^[1-2]\d$|^3[0-6]$/;return B(a)&&c.test(b)?a.toString(b).toUpperCase():a}}),b.module("a8m.math.shortFmt",["a8m.math"]).filter("shortFmt",["$math",function(a){return function(b,c){return B(c)&&isFinite(c)&&c%1===0&&c>=0&&B(b)&&isFinite(b)?1e3>b?b:1e6>b?i(b/1e3,c,a)+" K":1e9>b?i(b/1e6,c,a)+" M":i(b/1e9,c,a)+" B":"NaN"}}]),b.module("a8m.math.sum",[]).filter("sum",function(){return function(a,b){return D(a)?a.reduce(function(a,b){return a+b},b||0):a}}),b.module("a8m.ends-with",[]).filter("endsWith",function(){return function(a,b,c){var d,e=c||!1;return!A(a)||y(b)?a:(a=e?a:a.toLowerCase(),d=a.length-b.length,-1!==a.indexOf(e?b:b.toLowerCase(),d))}}),b.module("a8m.latinize",[]).filter("latinize",[function(){function a(a){return a.replace(/[^\u0000-\u007E]/g,function(a){return c[a]||a})}for(var b=[{base:"A",letters:"AⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ"},{base:"AA",letters:"Ꜳ"},{base:"AE",letters:"ÆǼǢ"},{base:"AO",letters:"Ꜵ"},{base:"AU",letters:"Ꜷ"},{base:"AV",letters:"ꜸꜺ"},{base:"AY",letters:"Ꜽ"},{base:"B",letters:"BⒷＢḂḄḆɃƂƁ"},{base:"C",letters:"CⒸＣĆĈĊČÇḈƇȻꜾ"},{base:"D",letters:"DⒹＤḊĎḌḐḒḎĐƋƊƉꝹ"},{base:"DZ",letters:"ǱǄ"},{base:"Dz",letters:"ǲǅ"},{base:"E",letters:"EⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎ"},{base:"F",letters:"FⒻＦḞƑꝻ"},{base:"G",letters:"GⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾ"},{base:"H",letters:"HⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ"},{base:"I",letters:"IⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ"},{base:"J",letters:"JⒿＪĴɈ"},{base:"K",letters:"KⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ"},{base:"L",letters:"LⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ"},{base:"LJ",letters:"Ǉ"},{base:"Lj",letters:"ǈ"},{base:"M",letters:"MⓂＭḾṀṂⱮƜ"},{base:"N",letters:"NⓃＮǸŃÑṄŇṆŅṊṈȠƝꞐꞤ"},{base:"NJ",letters:"Ǌ"},{base:"Nj",letters:"ǋ"},{base:"O",letters:"OⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ"},{base:"OI",letters:"Ƣ"},{base:"OO",letters:"Ꝏ"},{base:"OU",letters:"Ȣ"},{base:"OE",letters:"Œ"},{base:"oe",letters:"œ"},{base:"P",letters:"PⓅＰṔṖƤⱣꝐꝒꝔ"},{base:"Q",letters:"QⓆＱꝖꝘɊ"},{base:"R",letters:"RⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ"},{base:"S",letters:"SⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ"},{base:"T",letters:"TⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ"},{base:"TZ",letters:"Ꜩ"},{base:"U",letters:"UⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ"},{base:"V",letters:"VⓋＶṼṾƲꝞɅ"},{base:"VY",letters:"Ꝡ"},{base:"W",letters:"WⓌＷẀẂŴẆẄẈⱲ"},{base:"X",letters:"XⓍＸẊẌ"},{base:"Y",letters:"YⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ"},{base:"Z",letters:"ZⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ"},{base:"a",letters:"aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐ"},{base:"aa",letters:"ꜳ"},{base:"ae",letters:"æǽǣ"},{base:"ao",letters:"ꜵ"},{base:"au",letters:"ꜷ"},{base:"av",letters:"ꜹꜻ"},{base:"ay",letters:"ꜽ"},{base:"b",letters:"bⓑｂḃḅḇƀƃɓ"},{base:"c",letters:"cⓒｃćĉċčçḉƈȼꜿↄ"},{base:"d",letters:"dⓓｄḋďḍḑḓḏđƌɖɗꝺ"},{base:"dz",letters:"ǳǆ"},{base:"e",letters:"eⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇɛǝ"},{base:"f",letters:"fⓕｆḟƒꝼ"},{base:"g",letters:"gⓖｇǵĝḡğġǧģǥɠꞡᵹꝿ"},{base:"h",letters:"hⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ"},{base:"hv",letters:"ƕ"},{base:"i",letters:"iⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı"},{base:"j",letters:"jⓙｊĵǰɉ"},{base:"k",letters:"kⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ"},{base:"l",letters:"lⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇ"},{base:"lj",letters:"ǉ"},{base:"m",letters:"mⓜｍḿṁṃɱɯ"},{base:"n",letters:"nⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥ"},{base:"nj",letters:"ǌ"},{base:"o",letters:"oⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿɔꝋꝍɵ"},{base:"oi",letters:"ƣ"},{base:"ou",letters:"ȣ"},{base:"oo",letters:"ꝏ"},{base:"p",letters:"pⓟｐṕṗƥᵽꝑꝓꝕ"},{base:"q",letters:"qⓠｑɋꝗꝙ"},{base:"r",letters:"rⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ"},{base:"s",letters:"sⓢｓßśṥŝṡšṧṣṩșşȿꞩꞅẛ"},{base:"t",letters:"tⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ"},{base:"tz",letters:"ꜩ"},{base:"u",letters:"uⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ"},{base:"v",letters:"vⓥｖṽṿʋꝟʌ"},{base:"vy",letters:"ꝡ"},{base:"w",letters:"wⓦｗẁẃŵẇẅẘẉⱳ"},{base:"x",letters:"xⓧｘẋẍ"},{base:"y",letters:"yⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ"},{base:"z",letters:"zⓩｚźẑżžẓẕƶȥɀⱬꝣ"}],c={},d=0;d<b.length;d++)for(var e=b[d].letters.split(""),f=0;f<e.length;f++)c[e[f]]=b[d].base;return function(b){return A(b)?a(b):b}}]),b.module("a8m.ltrim",[]).filter("ltrim",function(){return function(a,b){var c=b||"\\s";return A(a)?a.replace(new RegExp("^"+c+"+"),""):a}}),b.module("a8m.match",[]).filter("match",function(){return function(a,b,c){var d=new RegExp(b,c);return A(a)?a.match(d):null}}),b.module("a8m.repeat",[]).filter("repeat",[function(){return function(a,b,c){var d=~~b;return A(a)&&d?w(a,--b,c||""):a}}]),b.module("a8m.rtrim",[]).filter("rtrim",function(){return function(a,b){var c=b||"\\s";return A(a)?a.replace(new RegExp(c+"+$"),""):a}}),b.module("a8m.slugify",[]).filter("slugify",[function(){return function(a,b){var c=y(b)?"-":b;return A(a)?a.toLowerCase().replace(/\s+/g,c):a}}]),b.module("a8m.starts-with",[]).filter("startsWith",function(){return function(a,b,c){var d=c||!1;return!A(a)||y(b)?a:(a=d?a:a.toLowerCase(),!a.indexOf(d?b:b.toLowerCase()))}}),b.module("a8m.stringular",[]).filter("stringular",function(){return function(a){var b=Array.prototype.slice.call(arguments,1);return a.replace(/{(\d+)}/g,function(a,c){return y(b[c])?a:b[c]})}}),b.module("a8m.strip-tags",[]).filter("stripTags",function(){return function(a){return A(a)?a.replace(/<\S[^><]*>/g,""):a}}),b.module("a8m.test",[]).filter("test",function(){return function(a,b,c){var d=new RegExp(b,c);return A(a)?d.test(a):a}}),b.module("a8m.trim",[]).filter("trim",function(){return function(a,b){var c=b||"\\s";return A(a)?a.replace(new RegExp("^"+c+"+|"+c+"+$","g"),""):a}}),b.module("a8m.truncate",[]).filter("truncate",function(){return function(a,b,c,d){return b=y(b)?a.length:b,d=d||!1,c=c||"",!A(a)||a.length<=b?a:a.substring(0,d?-1===a.indexOf(" ",b)?a.length:a.indexOf(" ",b):b)+c}}),b.module("a8m.ucfirst",[]).filter("ucfirst",[function(){return function(a){return A(a)?a.split(" ").map(function(a){return a.charAt(0).toUpperCase()+a.substring(1)}).join(" "):a}}]),b.module("a8m.uri-component-encode",[]).filter("uriComponentEncode",["$window",function(a){return function(b){return A(b)?a.encodeURIComponent(b):b}}]),b.module("a8m.uri-encode",[]).filter("uriEncode",["$window",function(a){return function(b){return A(b)?a.encodeURI(b):b}}]),b.module("a8m.wrap",[]).filter("wrap",function(){return function(a,b,c){return A(a)&&x(b)?[b,a,c||b].join(""):a}}),b.module("a8m.filter-watcher",[]).provider("filterWatcher",function(){this.$get=["$window","$rootScope",function(a,c){function d(a,c){return[a,b.toJson(c)].join("#").replace(/"/g,"")}function e(a){var b=a.targetScope.$id;E(l[b],function(a){delete j[a]}),delete l[b]}function f(){m(function(){c.$$phase||(j={})})}function g(a,b){var c=a.$id;return y(l[c])&&(a.$on("$destroy",e),l[c]=[]),l[c].push(b)}function h(a,b){var c=d(a,b);return j[c]}function i(a,b,c,e){var h=d(a,b);return j[h]=e,k(c)?g(c,h):f(),e}var j={},l={},m=a.setTimeout;return{isMemoized:h,memoize:i}}]}),b.module("angular.filter",["a8m.ucfirst","a8m.uri-encode","a8m.uri-component-encode","a8m.slugify","a8m.latinize","a8m.strip-tags","a8m.stringular","a8m.truncate","a8m.starts-with","a8m.ends-with","a8m.wrap","a8m.trim","a8m.ltrim","a8m.rtrim","a8m.repeat","a8m.test","a8m.match","a8m.to-array","a8m.concat","a8m.contains","a8m.unique","a8m.is-empty","a8m.after","a8m.after-where","a8m.before","a8m.before-where","a8m.defaults","a8m.where","a8m.reverse","a8m.remove","a8m.remove-with","a8m.group-by","a8m.count-by","a8m.search-field","a8m.fuzzy-by","a8m.fuzzy","a8m.omit","a8m.pick","a8m.every","a8m.filter-by","a8m.xor","a8m.map","a8m.first","a8m.last","a8m.flatten","a8m.join","a8m.math","a8m.math.max","a8m.math.min","a8m.math.percent","a8m.math.radix","a8m.math.sum","a8m.math.degrees","a8m.math.radians","a8m.math.byteFmt","a8m.math.kbFmt","a8m.math.shortFmt","a8m.angular","a8m.conditions","a8m.is-null","a8m.filter-watcher"])}(window,window.angular);
define('job-roles/controllers/controllers',[
    'common/angular'
], function (angular) {
    'use strict';

    return angular.module('hrjobroles.controllers', []);
});

define('job-roles/directives/directives',[
    'common/angular'
], function (angular) {
    'use strict';

    return angular.module('hrjobroles.directives', []);
});

define('job-roles/filters/filters',[
    'common/angular'
], function (angular) {
    'use strict';

    return angular.module('hrjobroles.filters', []);
});

define('job-roles/services/services',[
    'common/angular'
], function (angular) {
    'use strict';

    return angular.module('hrjobroles.services', []);
});

define('job-roles/controllers/hr-job-roles-controller',[
    'common/angular',
    'job-roles/controllers/controllers',
    'common/moment',
    'common/filters/angular-date/format-date'
], function (angular, controllers, moment) {
    'use strict';

    controllers.controller('HRJobRolesController', ['$scope', '$log', '$routeParams', '$route', '$timeout', '$filter', '$q', 'HR_settings', 'HRJobRolesService', 'DateValidation',
        function ($scope, $log, $routeParams, $route, $timeout, $filter, $q, HR_settings, HRJobRolesService, DateValidation) {
            $log.debug('Controller: HRJobRolesController');

            $scope.format = HR_settings.DATE_FORMAT;

            var me = this;

            $scope.present_job_roles = [];
            $scope.past_job_roles = [];

            $scope.dpOpen = function ($event) {
                $event.preventDefault();
                $event.stopPropagation();

                $scope.picker.opened = true;
            };

            /**
             * Method responsible for updating new JobRole with dates from Contract
             */
            $scope.onContractSelected = function () {
                var id = $scope.edit_data['new_role_id']['job_contract_id'];

                var contract = me.contractsData[id];
                var areDatesCustom = $scope.checkIfDatesAreCustom($scope.edit_data['new_role_id']['newStartDate'], $scope.edit_data['new_role_id']['newEndDate']);

                if (!areDatesCustom) {
                    if (!!contract.start_date) {
                        $scope.edit_data['new_role_id']['newStartDate'] = contract.start_date;
                    } else {
                        $scope.edit_data['new_role_id']['newStartDate'] = null;
                    }

                    if (!!contract.end_date) {
                        $scope.edit_data['new_role_id']['newEndDate'] = contract.end_date;
                    } else {
                        $scope.edit_data['new_role_id']['newEndDate'] = null;
                    }
                }
            };

            /**
             * Checks if dates don't exist in any of contracts
             * @param start
             * @param end
             * @returns {boolean}
             */
            $scope.checkIfDatesAreCustom = function (start, end) {
                if (start === '0000-00-00 00:00:00') start = null;
                if (end === '0000-00-00 00:00:00') end = null;

                var custom = true;

                if (!start) return false;


                angular.forEach(me.contractsData, function (value) {
                    if ($filter('formatDate')(start) === $filter('formatDate')(value.start_date)
                        && $filter('formatDate')(end) === $filter('formatDate')(value.end_date))
                        custom = false;
                });

                if (custom) {
                    console.info('Leaving old JobRole Dates.');
                }

                return custom;
            };

            /**
             * Method responsible for updating existing JobRole with dates from Contract
             * @param jobContractId
             * @param role_id
             */
            $scope.onContractEdited = function (jobContractId, role_id) {
                var id = jobContractId || $scope.edit_data[role_id]['job_contract_id'];

                var contract = me.contractsData[id];

                var areDatesCustom = $scope.checkIfDatesAreCustom($scope.edit_data[role_id]['start_date'], $scope.edit_data[role_id]['end_date']);

                if (!areDatesCustom) {
                    if (!!contract.start_date) {
                        $scope.edit_data[role_id]['start_date'] = contract.start_date;
                    } else {
                        $scope.edit_data[role_id]['start_date'] = null;
                    }

                    if (!!contract.end_date) {
                        $scope.edit_data[role_id]['end_date'] = contract.end_date;
                    } else {
                        $scope.edit_data[role_id]['end_date'] = null;
                    }
                }
            };

            /**
             *
             * @param title
             * @returns {string|undefined}
             */
            $scope.validateTitle = function (title) {
                if (title === 'title' || title === ' ') {
                    return "Title cannot be title!";
                }
            };

            /**
             * Trigger validation on JobRole Dates + attach error callback
             * @param start
             * @param end
             * @param {function} error
             */
            $scope.validateDates = function (start, end, error) {
                DateValidation.setErrorCallback(error);

                DateValidation.validate(start, end);
            };

            /**
             * Validation method for JobRole data.
             * If string is returned form is not submitted.
             * @param data
             * @returns {boolean|string}
             */
            $scope.validateRole = function (data) {
                var errors = 0;

                // Reset Error Messages
                data.start_date.$error.custom = [];
                data.end_date.$error.custom = [];

                $scope.validateDates(data.start_date.$viewValue, data.end_date.$viewValue, function (error, field) {
                    errors++;
                    if (field.indexOf('start_date') > -1) {
                        data.start_date.$error.custom.push(error);
                    }
                    if (field.indexOf('end_date') > -1) {
                        data.end_date.$error.custom.push(error);
                    }
                });

                return errors > 0 ? 'Error' : true;
            };

            $scope.today = function () {
                $scope.CalendarShow['newStartDate'] = false;
                $scope.CalendarShow['newEndDate'] = false;
                $scope.CalendarShow['start_date'] = false;
                $scope.CalendarShow['end_date'] = false;
            };

            $scope.isOpen = function (name) {
                return !!($scope.CalendarShow[name]);
            };

            // As default hide the datepickers
            $scope.CalendarShow = [];

            // Init values
            $scope.today();

            $scope.open = function (event) {
                $scope.CalendarShow[event] = true;
            };

            $scope.select = function (event) {
                $scope.CalendarShow[event] = false;
            };

            // Tracks collapsed / expanded rows
            $scope.collapsedRows = [];

            // Tracks clicked tabs per each row
            $scope.view_tab = [];

            // Tracks edit data changes on the forms
            $scope.edit_data = {};

            // Define the add new role URL
            $scope.add_new_role_url = $scope.$parent.pathBaseUrl + $scope.$parent.pathIncludeTpl + 'add_new_role.html';
            $scope.job_role_panel_url = $scope.$parent.pathBaseUrl + $scope.$parent.pathIncludeTpl + 'job_role_panel.html';

            // Store the contractsData
            $scope.contractsData = [];

            // Store the level types
            $scope.LevelsData = {};

            // Store the location types
            $scope.LocationsData = {};

            // Store the region types
            $scope.RegionsData = {};

            // Store the department types
            $scope.DepartmentsData = {};

            // Contact List IDs array to use for the select lists
            $scope.contactList = [];

            // Contact List object stores more details about the contact
            $scope.contactListObject = {};

            // Implement angular tabs
            $scope.changeTab = function (row_id, tab_id) {
                $scope.view_tab[row_id] = tab_id;
            };

            // Check if current tab
            $scope.isTab = function (row_id, tab_id) {
                return ($scope.view_tab[row_id] == tab_id);
            };

            // Check for collapsed rows
            $scope.isRowCollapsed = function (row_id) {
                return !!($scope.collapsedRows[row_id]);
            };

            // Collapse the row or Expand when clicked
            $scope.collapseRow = function (row_id) {
                $scope.collapsedRows[row_id] = !$scope.collapsedRows[row_id];
            };

            // Set the data from the webservice call
            $scope.initData = function (role_id, form_id, data) {

                // Check if we have the array already
                if (typeof $scope.edit_data[role_id] === "undefined") {
                    $scope.edit_data[role_id] = {};
                }
                // If we have funders or cost centers, we have a special way to init our data
                if (form_id === 'funders') {

                    // Init empty array for funder default values
                    $scope.edit_data[role_id]['funders'] = [];

                    // Split data from the stored funder contact IDs
                    var funder_contact_ids = data['funder'].split("|");

                    // Split the funder types
                    var funder_types = data['funder_val_type'].split("|");

                    // Split the percent value for the funder
                    var percent_funders = data['percent_pay_funder'].split("|");

                    // Split the amount value for the funder
                    var amount_funders = data['amount_pay_funder'].split("|");

                    // Loop data and crete the required array of values
                    for (var i = 0; i < funder_contact_ids.length; i++) {
                        if (funder_contact_ids[i] != "") {
                            // Set default funder rows funder rows
                            $scope.edit_data[role_id]['funders'].push({
                                id: $scope.edit_data[role_id]['funders'].length + 1,
                                funder_id: {
                                    id: funder_contact_ids[i],
                                    sort_name: job_roles.contactListObject[funder_contact_ids[i]]['sort_name']
                                },
                                type: funder_types[i],
                                percentage: percent_funders[i],
                                amount: amount_funders[i]
                            });
                        }
                    }
                }
                // If we have funders or cost centers, we have a special way to init our data
                else if (form_id === 'cost_centers') {
                    // Init empty array for funder default values
                    $scope.edit_data[role_id]['cost_centers'] = [];

                    // Split data from the stored funder contact IDs
                    var cost_center_contact_ids = data['cost_center'].split("|");

                    // Split the cost_centers types
                    var cost_center_types = data['cost_center_val_type'].split("|");

                    // Split the percent value for the cost_center
                    var percent_cost_centers = data['percent_pay_cost_center'].split("|");

                    // Split the amount value for the cost_center
                    var amount_cost_centers = data['amount_pay_cost_center'].split("|");

                    // Loop data and crete the required array of values
                    for (var i = 0; i < cost_center_contact_ids.length; i++) {

                        if (cost_center_contact_ids[i] != "") {

                            // Set default funder rows funder rows
                            $scope.edit_data[role_id]['cost_centers'].push({
                                id: $scope.edit_data[role_id]['cost_centers'].length + 1,
                                cost_centre_id: cost_center_contact_ids[i],
                                type: cost_center_types[i],
                                percentage: percent_cost_centers[i],
                                amount: amount_cost_centers[i]
                            });

                        }

                    }

                } else {

                    var bothJustSet = (typeof $scope.edit_data[role_id].start_date === 'undefined'
                    || typeof $scope.edit_data[role_id].job_contract_id === 'undefined');

                    // Default data init
                    $scope.edit_data[role_id][form_id] = data;

                    if (!!$scope.edit_data[role_id].start_date) {
                        var date = moment($scope.edit_data[role_id].start_date);
                        /* If dates are not set, we programatically set them here. */
                        var invalidDate = (isNaN(date) && typeof $scope.edit_data[role_id].start_date != 'undefined');

                        var presentJobContract = !(typeof $scope.edit_data[role_id].job_contract_id === 'undefined');

                        if (invalidDate && presentJobContract && bothJustSet) {
                            $scope.onContractEdited(null, role_id).then(function () {
                                $scope.$apply();
                                return $scope.updateRole(role_id);
                            });
                        }
                    }
                }

                if(form_id === 'end_date' && !$scope.edit_data[role_id].end_date){
                    $scope.edit_data[role_id].end_date = null;
                }

                if ($scope.edit_data[role_id].job_contract_id
                    && $scope.edit_data[role_id].start_date
                    && typeof $scope.edit_data[role_id].end_date != 'undefined'
                    && (form_id === 'start_date' || form_id === 'job_contract_id' || form_id === 'end_date')) {

                    updateRolesWithContractData(role_id);
                }
            };

            /**
             * Checks if JobRole dates are actual, if not checks if they exist in any of contract's revisions.
             * @param role_id
             */
            function updateRolesWithContractData(role_id) {
                var contract_id = $scope.edit_data[role_id].job_contract_id;

                if ($scope.checkIfDatesAreCustom($scope.edit_data[role_id]['start_date'], $scope.edit_data[role_id]['end_date'])) {
                    var contract = me.contractsData[contract_id];

                    // search for revision containing these dates
                    var revision = contract.revisions.some(function (rev) {
                        return rev.period_start_date === $filter('formatDate')($scope.edit_data[role_id]['start_date'])
                            && rev.period_end_date === $filter('formatDate')($scope.edit_data[role_id]['end_date']);
                    });

                    // check if dates match with revision
                    if (revision) {
                        $scope.edit_data[role_id]['start_date'] = contract.start_date;
                        $scope.edit_data[role_id]['end_date'] = contract.end_date;

                        $scope.updateRole(role_id);
                    }
                }
            }

            /**
             * Check if the data are changed in the form (based on job role ID)
             * @param row_id
             * @returns {boolean}
             */
            $scope.isChanged = function (row_id) {
                // If there are data it means we edited the form
                return !!($scope.edit_data[row_id]['is_edit']);
            };

            /**
             * Set the is_edit value
             * @param row_id
             */
            $scope.showSave = function (row_id) {
                $scope.edit_data[row_id]['is_edit'] = true;
            };

            /**
             * Check if we allow to submit the form
             * Rule -> Allow only if the minimum required data are filled
             * @returns {boolean}
             */
            $scope.checkNewRole = function checkNewRole() {

                return (typeof $scope.edit_data['new_role_id'] === 'undefined'
                || typeof $scope.edit_data['new_role_id']['title'] === 'undefined'
                || $scope.edit_data['new_role_id']['title'] === ''
                || typeof $scope.edit_data['new_role_id']['job_contract_id'] === 'undefined'
                || $scope.edit_data['new_role_id']['job_contract_id'] === '');
            };

            /**
             * Parse dates so they can be correctly read by server.
             *
             * @param {string|Date} date
             * @returns {string|null}
             */
            $scope.parseDate = function (date) {

                if (date instanceof Date) {
                    date = date.getTime();
                }

                var formatted = moment(date, [
                    'DD/MM/YYYY',
                    'x',
                    'YYYY-MM-DD'
                ]);

                return (formatted.isValid()) ? formatted.format('YYYY-MM-DD') : null;
            };

            /**
             * Validates Dates and saves the new Job Role
             */
            $scope.saveNewRole = function saveNewRole() {
                $log.debug('Add New Role');

                var errors = 0;

                $scope.errors = {};
                $scope.errors.newStartDate = [];
                $scope.errors.newEndDate = [];

                $scope.validateDates($scope.edit_data.new_role_id.newStartDate, $scope.edit_data.new_role_id.newEndDate, function (error, field) {
                    errors++;
                    if (field.indexOf('start_date') > -1) {
                        $scope.errors.newStartDate.push(error);
                    }
                    if (field.indexOf('end_date') > -1) {
                        $scope.errors.newEndDate.push(error);
                    }
                });

                if (!errors) {

                    $scope.edit_data.new_role_id.newStartDate = $scope.parseDate($scope.edit_data.new_role_id.newStartDate);

                    if ($scope.edit_data.new_role_id.newEndDate) {
                        $scope.edit_data.new_role_id.newEndDate = $scope.parseDate($scope.edit_data.new_role_id.newEndDate);
                    } else {
                        delete $scope.edit_data.new_role_id.newEndDate;
                    }

                    // Create the new job role
                    createJobRole($scope.edit_data.new_role_id).then(function () {
                        // Hide the add new form
                        $scope.add_new = false;

                        // Remove if any data are added / Reset form
                        delete $scope.edit_data['new_role_id'];

                        // Hide the empty message if visible
                        $scope.empty = false;

                        return getJobRolesList($scope.$parent.contactId);
                    });
                }
            };

            /**
             * Sets the add new job role form visibility
             */
            $scope.add_new_role = function () {
                $scope.add_new = true;
            };

            /**
             * Hides the add new job role form and removes any data added.
             */
            $scope.cancelNewRole = function () {
                $scope.add_new = false;
                delete $scope.edit_data['new_role_id'];
            };

            /**
             * Removes the Role based on Role ID
             * @param row_id
             */
            $scope.removeRole = function (row_id) {
                $log.debug('Remove Role');

                // Delete job role
                deleteJobRole(row_id).then(function () {
                    return getJobRolesList($scope.$parent.contactId);
                });
            };

            /**
             * Prepares data and updates existing role
             * @param role_id
             */
            $scope.updateRole = function (role_id) {
                $log.debug('Update Role');

                $scope.edit_data[role_id].start_date = $scope.parseDate($scope.edit_data[role_id].start_date);

                if ($scope.edit_data[role_id].end_date) {
                    $scope.edit_data[role_id].end_date = $scope.parseDate($scope.edit_data[role_id].end_date);
                } else {
                    delete $scope.edit_data[role_id].end_date;
                }

                // Update the job role
                updateJobRole(role_id, $scope.edit_data[role_id]).then(function () {
                    return getJobRolesList($scope.$parent.contactId);
                });
            };

            // Select list for Row Types (used for Funders and Cost Centers)
            $scope.rowTypes = {};
            $scope.rowTypes[0] = { id: 0, name: 'Fixed' };
            $scope.rowTypes[1] = { id: 1, name: '%' };

            //$scope.rowTypes = [ {id: 0, name: 'Fixed'}, {id: 1, name: '%'}];

            /**
             * Show Row Type default value
             * @param object
             * @returns {string}
             */
            $scope.showRowType = function (object) {
                var selected = '';

                if (typeof object.type !== "undefined") {

                    // Get the human readable Type Value
                    selected = $scope.rowTypes[object.type];

                    return selected.name;
                }
                return 'Not set';
            };

            $scope.getCostLabel = function (id) {
                var label = '';
                angular.forEach($scope.CostCentreList, function (v, k) {
                    if (v.id == id) {
                        label = v.title;
                    }
                });

                return label;
            };

            // Update funder type scope on request
            $scope.updateAdditionalRowType = function (role_id, row_type, key, data) {
                if (row_type === 'cost_centre') {
                    // Update cost centers row
                    $scope.edit_data[role_id]['cost_centers'][key]['type'] = data;
                } else {
                    // Update funder Type scope as default
                    $scope.edit_data[role_id]['funders'][key]['type'] = data;
                }
            };

            // Add additional rows (funder or cost centres)
            $scope.addAdditionalRow = function (role_id, row_type) {

                // Check if we have the array already
                if (typeof $scope.edit_data[role_id] === "undefined") {
                    $scope.edit_data[role_id] = {};
                }

                if (row_type === 'cost_centre') {

                    // Add cost centres
                    // Check if we have the array already
                    if (typeof $scope.edit_data[role_id]['cost_centers'] === "undefined" || !($scope.edit_data[role_id]['cost_centers'] instanceof Array)) {
                        $scope.edit_data[role_id]['cost_centers'] = [];
                    }

                    $scope.edit_data[role_id]['cost_centers'].push({
                        id: $scope.edit_data[role_id]['cost_centers'].length + 1,
                        cost_centre_id: '',
                        type: "1",
                        percentage: "0",
                        amount: "0"
                    });

                } else {

                    // As default add funder rows
                    // Check if we have the array already
                    if (typeof $scope.edit_data[role_id]['funders'] === "undefined" || !($scope.edit_data[role_id]['funders'] instanceof Array)) {
                        $scope.edit_data[role_id]['funders'] = [];
                    }

                    $scope.edit_data[role_id]['funders'].push({
                        id: $scope.edit_data[role_id]['funders'].length + 1,
                        funder_id: '',
                        type: "1",
                        percentage: "0",
                        amount: "0"
                    });
                }
            };

            // Delete Additional rows (funder or cost centres)
            $scope.deleteAdditionalRow = function (role_id, row_type, row_id) {
                if (row_type === 'cost_centre') {
                    // Remove the cost centre row
                    $scope.edit_data[role_id]['cost_centers'].splice(row_id, 1);
                } else {
                    // Remove the funder row as default
                    $scope.edit_data[role_id]['funders'].splice(row_id, 1);
                }
            };

            // Variable to check if we adding new job role
            var job_roles = this;

            // Get the option groups and option values
            getOptionValues();

            // Get job roles based on the passed Contact ID
            getJobRolesList($scope.$parent.contactId);

            // Get the contact list and store the data
            getContactList();

            function getContactList() {

                HRJobRolesService.getContactList().then(function (data) {

                        if (data.is_error === 1) {
                            job_roles.message_type = 'alert-danger';
                            job_roles.message = 'Cannot get contact lit!';
                        }
                        else {

                            // Pass the contact list to the scope
                            var contactList = [];
                            var contactListObject = {};

                            for (var i = 0; i < data.count; i++) {

                                // Build the contact list
                                contactList.push({ id: data.values[i]['id'], sort_name: data.values[i]['sort_name'] });
                                contactListObject[data.values[i]['id']] = {
                                    id: data.values[i]['id'],
                                    sort_name: data.values[i]['sort_name']
                                };
                            }

                            // Store the ContactList as Array as typeahead needs array what we can reuse later
                            job_roles.contactList = contactList;

                            // Store the object too, so we can point to right values by Contact ID
                            job_roles.contactListObject = contactListObject;

                            job_roles.message_type = 'alert-success';
                            job_roles.message = 'Contact list OK!';
                        }

                        // Hide the message after some seconds
                        $timeout(function () {
                            job_roles.message = null;
                        }, 3000);
                    },
                    function (errorMessage) {
                        $scope.error = errorMessage;
                    });
            }

            function getOptionValues() {

                // Set the option groups for which we want to get the values
                var option_groups = ['hrjc_department', 'hrjc_region', 'hrjc_location', 'hrjc_level_type', 'cost_centres'];

                HRJobRolesService.getOptionValues(option_groups).then(function (data) {

                        if (data.is_error === 1) {
                            job_roles.message_type = 'alert-danger';
                            job_roles.message = 'Cannot get option values!';
                        }
                        else {

                            // Pass the department option group list to the scope
                            var DepartmentList = {};

                            // Pass the region option group list to the scope
                            var RegionList = {};

                            // Pass the location option group list to the scope
                            var LocationList = {};

                            // Pass the level option group list to the scope
                            var LevelList = {};

                            // Pass the Cost Centers option group list to the scope
                            var CostCentreList = {};

                            angular.forEach(data['optionGroupData'], function (option_group_id, option_group_name) {

                                for (var i = 0; i < data.count; i++) {

                                    switch (option_group_name) {
                                        case 'hrjc_department':

                                            if (option_group_id === data.values[i]['option_group_id']) {
                                                // Build the department list
                                                DepartmentList[data.values[i]['id']] = {
                                                    id: data.values[i]['id'],
                                                    title: data.values[i]['label']
                                                };
                                            }

                                            break;
                                        case 'hrjc_region':

                                            if (option_group_id === data.values[i]['option_group_id']) {
                                                // Build the region list
                                                RegionList[data.values[i]['id']] = {
                                                    id: data.values[i]['id'],
                                                    title: data.values[i]['label']
                                                };
                                            }

                                            break;
                                        case 'hrjc_location':

                                            if (option_group_id === data.values[i]['option_group_id']) {
                                                // Build the contact list
                                                LocationList[data.values[i]['id']] = {
                                                    id: data.values[i]['id'],
                                                    title: data.values[i]['label']
                                                };
                                            }

                                            break;
                                        case 'hrjc_level_type':

                                            if (option_group_id === data.values[i]['option_group_id']) {
                                                // Build the contact list
                                                LevelList[data.values[i]['id']] = {
                                                    id: data.values[i]['id'],
                                                    title: data.values[i]['label']
                                                };

                                            }

                                            break;
                                        case 'cost_centres':

                                            if (option_group_id === data.values[i]['option_group_id']) {
                                                // Build the contact list
                                                CostCentreList[data.values[i]['id']] = {
                                                    id: data.values[i]['id'],
                                                    title: data.values[i]['label']
                                                };

                                            }

                                            break;
                                    }


                                }

                            });

                            // Store the Department types what we can reuse later
                            job_roles.DepartmentsData = DepartmentList;

                            // Store the Region types what we can reuse later
                            job_roles.RegionsData = RegionList;

                            // Store the Location types what we can reuse later
                            job_roles.LocationsData = LocationList;

                            // Store the Level types what we can reuse later
                            job_roles.LevelsData = LevelList;

                            // Store the Level types what we can reuse later
                            $scope.CostCentreList = CostCentreList;
                            $log.info($scope.CostCentreList);

                            job_roles.message_type = 'alert-success';
                            job_roles.message = 'Option values list OK!';
                        }

                        // Hide the message after some seconds
                        $timeout(function () {
                            job_roles.message = null;
                        }, 3000);
                    },
                    function (errorMessage) {
                        $scope.error = errorMessage;
                    });
            }

            /**
             * Get job roles based on the passed Contact ID (refresh part of the page)
             * @param contact_id
             * @returns {promise}
             */
            function getJobRolesList(contact_id) {
                var contractsPromise;
                if (!job_roles.job_contract_ids) {
                    contractsPromise = HRJobRolesService.getContracts(contact_id).then(function (data) {

                        var job_contract_ids = [];
                        var contractsData = {};

                        // If we have job contracts, try to get the job roles for the contract
                        if (data.count != 0) {
                            for (var i = 0; i < data.count; i++) {

                                // Job contract IDs which will be passed to the "getAllJobRoles" service
                                job_contract_ids.push(data.values[i]['id']);

                                var contract = {
                                    id: data.values[i]['id'],
                                    title: data.values[i]['title'],
                                    start_date: data.values[i]['period_start_date'],
                                    end_date: data.values[i]['period_end_date'],
                                    status: status,
                                    revisions: data.values[i]['revisions']
                                };

                                var optionalEndDate = $filter('formatDate')(contract.end_date) || 'Unspecified';
                                contract.label = contract.title + ' (' + $filter('formatDate')(contract.start_date) + ' - ' + optionalEndDate + ')';

                                contractsData[data.values[i]['id']] = contract;
                            }

                            // Store the ContractsData what we can reuse later
                            job_roles.contractsData = contractsData;

                            job_roles.job_contract_ids = job_contract_ids;

                            return job_contract_ids;
                        } else {
                            job_roles.empty = 'No Job Contracts found for this Contact!';
                        }
                    }, function (errorMessage) {
                        $scope.error = errorMessage;
                    });
                } else {
                    contractsPromise = $q.when(job_roles.job_contract_ids);
                }

                return contractsPromise.then(function (result) {
                    return HRJobRolesService.getAllJobRoles(result);
                }).then(function (data) {
                    // Assign data
                    job_roles.present_job_roles = [];
                    job_roles.past_job_roles = [];

                    data.values.forEach(function (object_data) {
                        if (!object_data.end_date || moment(object_data.end_date).isAfter(moment())) {
                            job_roles.present_job_roles.push(object_data);
                        } else {
                            job_roles.past_job_roles.push(object_data);
                        }
                    });

                    if (data.is_error === 1) {
                        job_roles.error = 'Data load failure';
                    } else if (data.count === 0) {
                        job_roles.empty = 'No Job Roles found!';
                    } else {
                        job_roles.empty = null;
                    }

                    job_roles.status = 'Data load OK';

                }, function (errorMessage) {
                    $scope.error = errorMessage;
                });
            }

            // Implements the "deleteJobRole" service
            function deleteJobRole(job_role_id) {

                return HRJobRolesService.deleteJobRole(job_role_id).then(function (data) {
                        if (data.is_error === 1) {
                            job_roles.message_type = 'alert-danger';
                            job_roles.message = 'Role delete failure!';
                        } else {
                            job_roles.message_type = 'alert-success';
                            job_roles.message = 'Role deleted successfully!';
                        }

                        // Hide the message after some seconds
                        $timeout(function () {
                            job_roles.message = null;
                        }, 3000);
                    },
                    function (errorMessage) {
                        $scope.error = errorMessage;
                    });

            }

            // Implements the "createJobRole" service
            function createJobRole(job_roles_data) {
                return HRJobRolesService.createJobRole(job_roles_data).then(function (data) {
                    if (data.is_error === 1) {
                        job_roles.message_type = 'alert-danger';
                        job_roles.message = 'Role creation failed!';
                    } else {
                        job_roles.message_type = 'alert-success';
                        job_roles.message = 'Role added successfully!';
                    }

                    // Hide the message after some seconds
                    $timeout(function () {
                        job_roles.message = null;
                    }, 3000);
                }, function (errorMessage) {
                    $scope.error = errorMessage;
                });
            }

            // Implements the "updateJobRole" service
            function updateJobRole(role_id, job_roles_data) {

                job_roles_data.end_date = $scope.parseDate(job_roles_data.end_date);
                job_roles_data.start_date = $scope.parseDate(job_roles_data.start_date);

                return HRJobRolesService.updateJobRole(role_id, job_roles_data).then(function (data) {

                    if (data.is_error === 1) {
                        job_roles.message_type = 'alert-danger';
                        job_roles.message = 'Role update failed!';
                    }
                    else {
                        job_roles.message_type = 'alert-success';
                        job_roles.message = 'Role updated successfully!';
                    }

                    // Hide the message after some seconds
                    $timeout(function () {
                        job_roles.message = null;
                    }, 3000);
                }, function (errorMessage) {
                    $scope.error = errorMessage;
                });
            }
        }
    ]);
});

define('job-roles/services/hr-job-roles-service',[
    'job-roles/services/services'
], function (services) {
    'use strict';

    services.factory('HRJobRolesService', ['$log', '$q', '$filter', function ($log, $q, $filter) {

        return {
            /**
             * Gets all contracts and revisions
             * @param contact_id
             * @returns {promise}
             */
            getContracts: function (contact_id) {
                var deferred = $q.defer();

                /**
                 * Get contracts for given contact.
                 */
                CRM.api3('HRJobContract', 'get', {
                    "sequential": 1,
                    "contact_id": contact_id,
                    "deleted": 0,
                    "return": "title,period_end_date,period_start_date"
                }).done(function (contracts) {
                    // get revisions for each contract
                    var revisions = contracts.values.map(function (contract) {
                        return CRM.api3('HRJobContractRevision', 'get', {
                            "sequential": 1,
                            "jobcontract_id": contract.id
                        }).then(function (response) {
                            return response.values.map(function (item) {
                                return {
                                    id: item.id,
                                    contract_id: item.jobcontract_id
                                }
                            });
                        });
                    });

                    $q.all(revisions).then(function (response) {
                        // Flatten the array of revisions
                        return [].concat.apply([], response);
                    }).then(function (response) {
                        // get details for each revision
                        return $q.all(response.map(function (item) {
                            return CRM.api3('HRJobDetails', 'get', {
                                "sequential": 1,
                                "jobcontract_revision_id": item.id
                            }).then(function (result) {
                                result.job_contract_id = item.contract_id;
                                return result;
                            });
                        }));
                    }).then(function (revisions) {
                        // for each contract
                        contracts.values.forEach(function (contract) {

                            // filter revisions by contract.id and remove current
                            contract.revisions = revisions.filter(function (revision) {
                                var isCurrent = (revision.values[0].period_start_date === contract.period_start_date
                                && revision.values[0].period_end_date === contract.period_end_date);

                                return !isCurrent && revision.job_contract_id === contract.id;
                            });

                            // save revisions in contract.revisions with properly formatted dates
                            contract.revisions = contract.revisions.map(function (revisions) {
                                var revision = revisions.values[0];
                                revision.period_start_date = $filter('formatDate')(revision.period_start_date);
                                revision.period_end_date = $filter('formatDate')(revision.period_end_date);
                                return revision;
                            });
                        });

                        // Passing data to deferred's resolve function on successful completion
                        deferred.resolve(contracts);
                    });
                }).error(function (result) {

                    // Sending a friendly error message in case of failure
                    deferred.reject("An error occured while fetching items");

                });

                // Returning the promise object
                return deferred.promise;
            },

            getContractDetails: function getContractDetails(id) {
                return CRM.api3('HRJobContractRevision', 'getcurrentrevision', {
                    "sequential": 1,
                    "jobcontract_id": id
                }).then(function (result) {
                    return CRM.api3('HRJobDetails', 'get', {
                        "sequential": 1,
                        "jobcontract_id": id,
                        "jobcontract_revision_id": result.values.details_revision_id
                    });
                });
            },

            getAllJobRoles: function (job_contract_ids) {

                var deferred = $q.defer();

                CRM.api3('HrJobRoles', 'get', {
                    "sequential": 1,
                    "return": "id,job_contract_id,title,description,status,funder,funder_val_type,percent_pay_funder,amount_pay_funder,cost_center,cost_center_val_type,percent_pay_cost_center,amount_pay_cost_center,level_type,location,region,department,end_date,start_date",
                    "job_contract_id": { "IN": job_contract_ids }
                }).done(function (result) {

                    // Passing data to deferred's resolve function on successful completion
                    deferred.resolve(result);

                }).error(function (result) {

                    // Sending a friendly error message in case of failure
                    deferred.reject("An error occured while fetching items");

                });

                // Returning the promise object
                return deferred.promise;

            },

            deleteJobRole: function (job_role_id) {

                var deferred = $q.defer();

                CRM.api3('HrJobRoles', 'delete', {
                    "sequential": 1,
                    "id": job_role_id
                }).done(function (result) {

                    // Passing data to deferred's resolve function on successful completion
                    deferred.resolve(result);

                }).error(function (result) {

                    // Sending a friendly error message in case of failure
                    deferred.reject("An error occured while deleting items");

                });

                // Returning the promise object
                return deferred.promise;

            },

            createJobRole: function (job_roles_data) {

                // Define funder IDs string
                var funders = "|";

                // Set the funder types
                var funder_types = "|";

                // Set the percent value for the funder
                var percent_funders = "|";

                // Set the amount value for the funder
                var amount_funders = "|";

                // Define cost_center IDs string
                var cost_centers = "|";

                // Set the cost_center types
                var cost_center_types = "|";

                // Set the percent value for the cost_center
                var percent_cost_centers = "|";

                // Set the amount value for the cost_center
                var amount_cost_centers = "|";

                // If we have any funders added, loop and save them
                if (typeof job_roles_data.funders !== "undefined") {

                    // Loop funders and set up the data to store the funders
                    for (var i = 0, l = job_roles_data.funders.length; i < l; i++) {

                        if (job_roles_data.funders[i]) {
                            funders += job_roles_data.funders[i]['funder_id']['id'] + "|";
                            funder_types += job_roles_data.funders[i]['type'] + "|";
                            percent_funders += job_roles_data.funders[i]['percentage'] + "|";
                            amount_funders += job_roles_data.funders[i]['amount'] + "|";
                        }
                    }
                }

                // If we have any cost_centers added, loop and save them
                if (typeof job_roles_data.cost_centers !== "undefined") {

                    // Loop cost_centers and set up the data to store the cost_centers
                    for (i = 0, l = job_roles_data.cost_centers.length; i < l; i++) {

                        if (job_roles_data.cost_centers[i]) {
                            cost_centers += job_roles_data.cost_centers[i]['cost_centre_id'] + "|";
                            cost_center_types += job_roles_data.cost_centers[i]['type'] + "|";
                            percent_cost_centers += job_roles_data.cost_centers[i]['percentage'] + "|";
                            amount_cost_centers += job_roles_data.cost_centers[i]['amount'] + "|";
                        }
                    }
                }

                var deferred = $q.defer();
                //FIXME 'solution' to the bug failing saving correct dates to DB a first save
                this.getNewJobRole(job_roles_data.job_contract_id).then(function (result) {

                    return CRM.api3('HrJobRoles', 'update', {
                        "id": result.id,
                        "sequential": 1,
                        "job_contract_id": job_roles_data.job_contract_id,
                        "title": job_roles_data.title,
                        "description": job_roles_data.description,
                        "funder": funders,
                        "funder_val_type": funder_types,
                        "percent_pay_funder": percent_funders,
                        "amount_pay_funder": amount_funders,
                        "cost_center": cost_centers,
                        "cost_center_val_type": cost_center_types,
                        "percent_pay_cost_center": percent_cost_centers,
                        "amount_pay_cost_center": amount_cost_centers,
                        "level_type": job_roles_data.level,
                        "location": job_roles_data.location,
                        "region": job_roles_data.region,
                        "department": job_roles_data.department,
                        "start_date": job_roles_data.newStartDate,
                        "end_date": job_roles_data.newEndDate || 0
                    });
                }).then(function (response) {
                    // Passing data to deferred's resolve function on successful completion
                    deferred.resolve(response);
                }, function (result) {
                    // Sending a friendly error message in case of failure
                    deferred.reject("An error occured while adding items");
                });

                // Returning the promise object
                return deferred.promise;

            },

            updateJobRole: function (role_id, job_roles_data) {

                // Define funder IDs string
                var funders = "|";

                // Set the funder types
                var funder_types = "|";

                // Set the percent value for the funder
                var percent_funders = "|";

                // Set the amount value for the funder
                var amount_funders = "|";

                // Define cost_center IDs string
                var cost_centers = "|";

                // Set the cost_center types
                var cost_center_types = "|";

                // Set the percent value for the cost_center
                var percent_cost_centers = "|";

                // Set the amount value for the cost_center
                var amount_cost_centers = "|";

                // If we have any funders added, loop and save them
                if (typeof job_roles_data.funders !== "undefined") {
                    // Loop funders and set up the data to store the funders
                    for (var i = 0, l = job_roles_data.funders.length; i < l; i++) {

                        if (job_roles_data.funders[i]) {
                            funders += job_roles_data.funders[i]['funder_id']['id'] + "|";
                            funder_types += job_roles_data.funders[i]['type'] + "|";
                            percent_funders += job_roles_data.funders[i]['percentage'] + "|";
                            amount_funders += job_roles_data.funders[i]['amount'] + "|";
                        }
                    }
                }

                // If we have any cost_centers added, loop and save them
                if (typeof job_roles_data.cost_centers !== "undefined") {

                    // Loop cost_centers and set up the data to store the cost_centers
                    for (var i = 0, l = job_roles_data.cost_centers.length; i < l; i++) {

                        if (job_roles_data.cost_centers[i]) {
                            cost_centers += job_roles_data.cost_centers[i]['cost_centre_id'] + "|";
                            cost_center_types += job_roles_data.cost_centers[i]['type'] + "|";
                            percent_cost_centers += job_roles_data.cost_centers[i]['percentage'] + "|";
                            amount_cost_centers += job_roles_data.cost_centers[i]['amount'] + "|";
                        }
                    }
                }

                var deferred = $q.defer();

                CRM.api3('HrJobRoles', 'create', {
                    "sequential": 1,
                    "id": role_id,
                    "job_contract_id": job_roles_data.job_contract_id,
                    "title": job_roles_data.title,
                    "description": job_roles_data.description,
                    "status": job_roles_data.status,
                    "funder": funders,
                    "funder_val_type": funder_types,
                    "percent_pay_funder": percent_funders,
                    "amount_pay_funder": amount_funders,
                    "cost_center": cost_centers,
                    "cost_center_val_type": cost_center_types,
                    "percent_pay_cost_center": percent_cost_centers,
                    "amount_pay_cost_center": amount_cost_centers,
                    "level_type": job_roles_data.level,
                    "location": job_roles_data.location,
                    "region": job_roles_data.region,
                    "start_date": job_roles_data.start_date,
                    "end_date": job_roles_data.end_date || 0,
                    "department": job_roles_data.department

                }).done(function (result) {

                    // Passing data to deferred's resolve function on successful completion
                    deferred.resolve(result);

                }).error(function (result) {

                    // Sending a friendly error message in case of failure
                    deferred.reject("An error occured while updating items");

                });

                // Returning the promise object
                return deferred.promise;

            },

            getContactList: function (search_value) {

                var deferred = $q.defer();

                CRM.api3('Contact', 'get', {
                    "sequential": 1,
                    "return": "id,sort_name"
                }).done(function (result) {

                    // Passing data to deferred's resolve function on successful completion
                    deferred.resolve(result);

                }).error(function (result) {

                    // Sending a friendly error message in case of failure
                    deferred.reject("An error occured while fetching items");

                });

                // Returning the promise object
                return deferred.promise;

            },

            getOptionValues: function (option_group_name) {

                var deferred = $q.defer();

                // Define option group names and IDs
                var optionGroupData = {};

                CRM.api3('OptionGroup', 'get', {
                    "sequential": 1,
                    "name": { "IN": option_group_name },
                    "options": { "limit": 1000 }
                }).done(function (option_group_data) {

                    if (option_group_data.is_error !== 1) {

                        var option_group_ids = [];

                        angular.forEach(option_group_data['values'], function (option_group, key) {

                            // Store the option group names and IDs
                            optionGroupData[option_group['name']] = option_group['id'];

                            // Prepare option group IDs for the API call
                            option_group_ids.push(option_group['id']);

                        });

                        CRM.api3('OptionValue', 'get', {
                            "sequential": 1,
                            "option_group_id": { "IN": option_group_ids },
                            "options": { "limit": 1000 }
                        }).done(function (result) {

                            // Pass the additional info about optionGroupData
                            result['optionGroupData'] = optionGroupData;

                            // Passing data to deferred's resolve function on successful completion
                            deferred.resolve(result);

                        }).error(function (result) {

                            // Sending a friendly error message in case of failure
                            deferred.reject("An error occured while fetching items");

                        });

                    }

                });

                // Returning the promise object
                return deferred.promise;

            },

            getNewJobRole: function getNewJobRole(contract_id) {
                //Creates new JobRole depending on contract id and returns promise
                return CRM.api3('HrJobRoles', 'create', {
                    "sequential": 1,
                    "job_contract_id": contract_id,
                    "title": ''
                });
            }

        }
    }]);

});

define('job-roles/services/date-validation',[
    'job-roles/services/services',
    'common/moment'
], function (module, moment) {
    /**
     * Service responsible for validating dates in HRJobRoles
     * @constructor
     */
    module.factory('DateValidation', ['HR_settings', function (HR_settings) {
        /**
         *
         * @param error_msg
         * @param fields
         * @private
         */
        var _error = function (error_msg, fields) {
            throw new Error(error_msg, fields[0]);
        };

        /**
         * Method checking whether provided date is valid
         * @param {moment} date
         * @param {string[]} fields
         */
        function checkIfValuesAreValid(date, fields) {
            if (!date.isValid()) {
                _error('Date is not valid!!', fields);
            }
        };

        /**
         * Method checking whether dates are in valid order
         * @param {moment} start
         * @param {moment} end
         */
        function checkIfStartDateIsLower (start, end) {
            if (start.isSameOrAfter(end)) {
                _error('Start Date cannot be the same as or after the End Date.', ['start_date', 'end_date']);
            }
        }

        var Validation = {
            dateFormats: [
                'x',
                'YYYY-MM-DD'
            ],

            /**
             * Set custom error callback
             * @param {function} error
             */
            setErrorCallback: function setErrorCallback(error) {
                if (typeof error === 'function') {
                    _error = error;
                } else {
                    throw new TypeError('Error callback must be a function.');
                }
            },

            /**
             * Validates Dates
             * @param {Date|string|int} start
             * @param {Date|string|int} end
             */
            validate: function validate(start, end) {
                if (start instanceof Date) {
                    start = start.getTime();
                }

                if (end instanceof Date) {
                    end = end.getTime();
                }

                var start_date = moment(start, this.dateFormats, true);
                var end_date = moment(end, this.dateFormats, true);

                checkIfValuesAreValid(start_date, ['start_date']);

                if (end === 0 || end) {
                    checkIfValuesAreValid(end_date, ['end_date']);

                    if (start) {
                        checkIfStartDateIsLower(start_date, end_date);
                    }
                }
            }
        };
        HR_settings.DATE_FORMAT && Validation.dateFormats.push(HR_settings.DATE_FORMAT.toUpperCase());

        return Validation;
    }]);
});

define('job-roles/directives/example',[
    'job-roles/directives/directives'
], function (directives) {
    'use strict';

    directives.directive('example',['$rootScope','$log',function ($rootScope, $log) {
        $log.debug('Directive: example');

        return {
            link: function ($scope, el, attrs) {

            }
        }
    }]);
});

define('job-roles/app',[
    'job-roles/vendor/angular-editable',
    'job-roles/vendor/angular-filter',
    'job-roles/controllers/controllers',
    'job-roles/directives/directives',
    'job-roles/filters/filters',
    'job-roles/services/services',
    'job-roles/controllers/hr-job-roles-controller',
    'job-roles/services/hr-job-roles-service',
    'job-roles/services/date-validation',
    'job-roles/directives/example',
    'common/services/angular-date/date-format',
    'common/modules/routers/compu-ng-route',
    'common/directives/angular-date/date-input'
], function () {
    'use strict';

    angular.module('hrjobroles', [
        'ngAnimate',
        'common.angularDate',
        'compuNgRoute',
        'xeditable',
        'angular.filter',
        'ngResource',
        'ui.bootstrap',
        'hrjobroles.controllers',
        'hrjobroles.directives',
        'hrjobroles.filters',
        'hrjobroles.services'
    ])
    .constant('settings', {
        classNamePrefix: 'hrjobroles-',
        contactId: decodeURIComponent((new RegExp('[?|&]cid=([^&;]+?)(&|#|;|$)').exec(location.search)||[,""])[1].replace(/\+/g, '%20'))||null,
        debug: true,
        pathApp: '',
        pathRest: CRM.url('civicrm/ajax/rest'),
        pathBaseUrl: CRM.vars.hrjobroles.baseURL + '/',
        pathTpl: 'views/',
        pathIncludeTpl: 'views/include/'
    })
    .config(['settings','$routeProvider','$resourceProvider','$httpProvider','$logProvider',
        function(settings, $routeProvider, $resourceProvider, $httpProvider, $logProvider){
            $logProvider.debugEnabled(settings.debug);

            $routeProvider
                .resolveForAll({
                    format: ['DateFormat', function(DateFormat){
                        return DateFormat.getDateFormat();
                    }]
                })
                .when('/', {
                    templateUrl: settings.pathBaseUrl + settings.pathTpl + 'mainTemplate.html?v=1',
                    resolve: {},
                    controller: 'HRJobRolesController',
                    controllerAs: 'jobroles'
                })
                .otherwise({redirectTo:'/'});

            $resourceProvider.defaults.stripTrailingSlashes = false;

            $httpProvider.defaults.headers.common["X-Requested-With"] = 'XMLHttpRequest';
        }
    ])
    .run(['settings','$rootScope','$q', '$log', 'editableOptions',
        function(settings, $rootScope, $q, $log, editableOptions){
            $log.debug('app.run');

            // Set bootstrap 3 as default theme
            editableOptions.theme = 'bs3';

            // Pass the values from our settings
            $rootScope.contactId = settings.contactId;
            $rootScope.pathBaseUrl = settings.pathBaseUrl;
            $rootScope.pathTpl = settings.pathTpl;
            $rootScope.pathIncludeTpl = settings.pathIncludeTpl;
            $rootScope.prefix = settings.classNamePrefix;

        }
    ]);
});

(function () {
    var extPath = CRM.vars.hrjobroles.baseURL + '/js/src/job-roles';

    require.config({
        urlArgs: 'bust=' + (new Date()).getTime(),
        paths: {
            'job-roles': extPath,
            'job-roles/vendor/angular-editable': extPath + '/vendor/angular/xeditable.min',
            'job-roles/vendor/angular-filter': extPath + '/vendor/angular/angular-filter.min'
        }
    });

    require(['job-roles/app'], function (app) {
        'use strict';

        document.addEventListener('hrjobrolesLoad', function(){
            angular.bootstrap(document.getElementById('hrjobroles'), ['hrjobroles']);
        });
    });
})(require);

